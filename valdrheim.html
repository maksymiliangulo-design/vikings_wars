<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Valdrheim — Prototype (isometric top-down, terrain integrated)</title>
  <style>
    html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial}
    #app{width:100%;height:100%;overflow:hidden;position:relative;background:#0b0f12}
    canvas{display:block}
    .ui {
      position: absolute; left: 12px; top: 12px; z-index: 10;
      background: rgba(10,10,12,0.75); padding:10px; border-radius:8px; color:#e7eef6;
      box-shadow: 0 6px 20px rgba(0,0,0,0.5);
    }
    .ui h1{margin:0 0 8px 0;font-size:14px}
    .btn{display:inline-block;padding:6px 10px;margin:4px;border-radius:6px;background:#2b3640;color:#fff;cursor:pointer}
    .btn.disabled{opacity:0.45;pointer-events:none}
    .resources{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.06);padding:8px;border-radius:8px;color:#fff}
    .hint{position:absolute;left:12px;bottom:12px;color:#cbd5e1;background:rgba(0,0,0,0.4);padding:8px;border-radius:6px}
  </style>
</head>
<body>
<div id="app">
  <div class="ui">
    <h1>Valdrheim — Prototype</h1>
    <div>
      <button id="spawnViking" class="btn disabled">Spawn Viking</button>
      <button id="spawnSamurai" class="btn disabled">Spawn Samurai</button>
      <button id="spawnKnight" class="btn disabled">Spawn Knight</button>
      <button id="reset" class="btn">Reset</button>
    </div>
    <div style="margin-top:8px;font-size:12px;color:#a8b5c3">Left click select unit • Right click move • Scroll zoom • Drag to pan</div>
    <div style="margin-top:6px;font-size:12px;color:#a8b5c3">Terrain: <span id="terrainStatus">loading...</span></div>
  </div>
  <div class="resources" id="resBox">Drewno: 100 &nbsp; Żelazo: 60 &nbsp; Złoto: 40</div>
  <div class="hint">Selected: <span id="selectedLabel">—</span></div>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.161.0/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.161.0/examples/jsm/controls/OrbitControls.js';

const app = document.getElementById('app');
const terrainStatus = document.getElementById('terrainStatus');
const spawnVikingBtn = document.getElementById('spawnViking');
const spawnSamuraiBtn = document.getElementById('spawnSamurai');
const spawnKnightBtn = document.getElementById('spawnKnight');
const resetBtn = document.getElementById('reset');

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111217);
scene.fog = new THREE.Fog(0x111217, 160, 400);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
app.appendChild(renderer.domElement);

// Camera — isometric-ish top-down
const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 80, 120);
camera.lookAt(0,0,0);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = false; // keep top-down feel
controls.enablePan = true;
controls.enableDamping = true;
controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI/2.05;
controls.minDistance = 20;
controls.maxDistance = 220;

// Lights
const dir = new THREE.DirectionalLight(0xffffff, 0.9);
dir.position.set(60,150,30);
dir.castShadow = true;
dir.shadow.camera.left = -150; dir.shadow.camera.right = 150; dir.shadow.camera.top = 150; dir.shadow.camera.bottom = -150;
scene.add(dir);
const amb = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(amb);

// Global terrain reference and parameters
let terrain = null;
let terrainWidth = 200, terrainDepth = 200;
let terrainReady = false;

// Units container
const units = [];
let selectedUnit = null;

// Raycaster
const ray = new THREE.Raycaster();
const pointer = new THREE.Vector2();

// Texture loader — load the concept map and create heightfield
const texLoader = new THREE.TextureLoader();
// Path to image generated earlier; make sure file is in same folder or adjust path
const MAP_IMAGE = 'A_top-down_isometric_digital_illustration_of_Vald.png';

texLoader.load(MAP_IMAGE, (colorMap) => {
  // create terrain based on colorMap
  const img = colorMap.image;
  // create canvas to read pixels
  const canvas = document.createElement('canvas');
  canvas.width = img.width; canvas.height = img.height;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0);
  const imgData = ctx.getImageData(0,0,img.width,img.height).data;

  // geometry with segments matching image for accurate height mapping
  const geometry = new THREE.PlaneGeometry(terrainWidth, terrainDepth, img.width-1, img.height-1);

  const pos = geometry.attributes.position;
  for(let i=0;i<pos.count;i++){
    const ix = i % img.width;
    const iz = Math.floor(i / img.width);
    const idx = (iz * img.width + ix) * 4;
    const r = imgData[idx], g = imgData[idx+1], b = imgData[idx+2];
    const brightness = (r + g + b) / 3 / 255;
    pos.setY(i, brightness * 18); // height scale — tweak if needed
  }
  geometry.computeVertexNormals();

  const material = new THREE.MeshStandardMaterial({ map: colorMap, roughness:0.95, metalness:0.0 });
  terrain = new THREE.Mesh(geometry, material);
  terrain.rotation.x = -Math.PI/2;
  terrain.receiveShadow = true;
  terrain.castShadow = false;
  scene.add(terrain);

  terrainReady = true;
  terrainStatus.innerText = 'loaded';
  spawnVikingBtn.classList.remove('disabled');
  spawnSamuraiBtn.classList.remove('disabled');
  spawnKnightBtn.classList.remove('disabled');

  // add a subtle outline/edge using a wireframe low-opacity mesh (debug, optional)
  const wf = new THREE.LineSegments(new THREE.WireframeGeometry(geometry), new THREE.LineBasicMaterial({color:0x000000, opacity:0.06, transparent:true}));
  wf.rotation.x = -Math.PI/2; scene.add(wf);

  // add center ruins object (placed relative to terrain center)
  const ruins = new THREE.Mesh(new THREE.TorusKnotGeometry(6,1.6,64,8), new THREE.MeshStandardMaterial({color:0x6e584f, metalness:0.2, roughness:0.7}));
  ruins.position.set(0,6,0); scene.add(ruins);

  // create initial demo units once terrain exists
  spawnUnit('viking', new THREE.Vector3(-60,0,-60));
  spawnUnit('samurai', new THREE.Vector3(60,0,-60));
  spawnUnit('knight', new THREE.Vector3(60,0,60));
});

// utility: raycast down at x,z to get terrain height
function getHeightAt(x, z){
  if(!terrain) return 0;
  const origin = new THREE.Vector3(x, 500, z);
  const dirDown = new THREE.Vector3(0,-1,0);
  ray.set(origin, dirDown);
  const hits = ray.intersectObject(terrain);
  if(hits.length>0) return hits[0].point.y;
  return 0;
}

// spawn unit (will raycast to place on terrain)
function spawnUnit(type, approxPos){
  if(!terrainReady) return null;
  // approximate pos x,z provided; find exact y on terrain
  const x = approxPos.x, z = approxPos.z;
  const y = getHeightAt(x,z) + 1.2; // lift a bit above surface

  const color = type==='viking'?0x2f95ff:(type==='samurai'?0xff6f61:0xf6d55c);
  const geom = new THREE.CapsuleGeometry(1,1,4,8);
  const mat = new THREE.MeshStandardMaterial({color});
  const mesh = new THREE.Mesh(geom, mat);
  mesh.position.set(x, y, z);
  mesh.castShadow = true;
  mesh.userData = {type, hp:100, speed: 6 + (type==='samurai'?2:0), target:null, id: Math.random().toString(36).slice(2,9)};
  scene.add(mesh);
  units.push(mesh);
  return mesh;
}

// button handlers
spawnVikingBtn.addEventListener('click', ()=>{
  if(!terrainReady) return; spawnUnit('viking', new THREE.Vector3(-60,0,-60));
});
spawnSamuraiBtn.addEventListener('click', ()=>{
  if(!terrainReady) return; spawnUnit('samurai', new THREE.Vector3(60,0,-60));
});
spawnKnightBtn.addEventListener('click', ()=>{
  if(!terrainReady) return; spawnUnit('knight', new THREE.Vector3(60,0,60));
});
resetBtn.addEventListener('click', ()=>{
  for(const u of units) scene.remove(u);
  units.length = 0; selectedUnit = null; document.getElementById('selectedLabel').innerText='—';
});

// selection on left-click
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  if(ev.button === 0){
    pointer.x = (ev.clientX / window.innerWidth) * 2 - 1;
    pointer.y = - (ev.clientY / window.innerHeight) * 2 + 1;
    ray.setFromCamera(pointer, camera);
    const hits = ray.intersectObjects(units);
    if(hits.length>0){
      selectedUnit = hits[0].object;
      document.getElementById('selectedLabel').innerText = selectedUnit.userData.type + ' • ' + selectedUnit.userData.id;
    } else {
      selectedUnit = null; document.getElementById('selectedLabel').innerText = '—';
    }
  }
});

// right-click to move (raycast against terrain)
renderer.domElement.addEventListener('contextmenu', (ev)=>{
  ev.preventDefault();
  if(!terrainReady || !selectedUnit) return;
  pointer.x = (ev.clientX / window.innerWidth) * 2 - 1;
  pointer.y = - (ev.clientY / window.innerHeight) * 2 + 1;
  ray.setFromCamera(pointer, camera);
  const hit = ray.intersectObject(terrain)[0];
  if(hit){
    selectedUnit.userData.target = new THREE.Vector3(hit.point.x, hit.point.y + 1.2, hit.point.z);
  }
});

// movement update & lookAt
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  for(const u of units){
    const t = u.userData.target;
    if(t){
      const dir = new THREE.Vector3().subVectors(t, u.position);
      const dist = dir.length();
      if(dist > 0.4){
        dir.normalize();
        // move horizontally and sample terrain height to keep on surface
        u.position.addScaledVector(new THREE.Vector3(dir.x, 0, dir.z), u.userData.speed * dt);
        const newY = getHeightAt(u.position.x, u.position.z) + 1.2;
        u.position.y = THREE.MathUtils.lerp(u.position.y, newY, 0.4);
        u.lookAt(t.x, u.position.y, t.z);
      } else {
        u.userData.target = null;
      }
    }
  }

  controls.update();
  renderer.render(scene, camera);
}
animate();

// resize
window.addEventListener('resize', ()=>{
  renderer.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
});

</script>
</body>
</html>
